#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include "auth_privpass_token.h"
#include "auth_params.h"
#include "bsl_sal.h"
#include "bsl_err.h"
#include "crypt_eal_init.h"
#include "crypt_eal_rand.h"
#include "auth_errno.h"
#include "crypt_errno.h"

uint8_t pubKey[] = {0x30, 0x82, 0x01, 0x52, 0x30, 0x3d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
    0x0a, 0x30, 0x30, 0xa0, 0x0d, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04,
    0x02, 0x02, 0xa1, 0x1a, 0x30, 0x18, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
    0x08, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0xa2, 0x03,
    0x02, 0x01, 0x30, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xcb, 0x1a, 0xed, 0x6b, 0x6a, 0x95, 0xf5, 0xb1, 0xce, 0x01, 0x3a, 0x4c, 0xfc, 0xab, 0x25,
    0xb9, 0x4b, 0x2e, 0x64, 0xa2, 0x30, 0x34, 0xe4, 0x25, 0x0a, 0x7e, 0xab, 0x43, 0xc0, 0xdf, 0x3a,
    0x8c, 0x12, 0x99, 0x3a, 0xf1, 0x2b, 0x11, 0x19, 0x08, 0xd4, 0xb4, 0x71, 0xbe, 0xc3, 0x1d, 0x4b,
    0x6c, 0x9a, 0xd9, 0xcd, 0xda, 0x90, 0x61, 0x2a, 0x2e, 0xe9, 0x03, 0x52, 0x3e, 0x6d, 0xe5, 0xa2,
    0x24, 0xd6, 0xb0, 0x2f, 0x09, 0xe5, 0xc3, 0x74, 0xd0, 0xcf, 0xe0, 0x1d, 0x8f, 0x52, 0x9c, 0x50,
    0x0a, 0x78, 0xa2, 0xf6, 0x79, 0x08, 0xfa, 0x68, 0x2b, 0x5a, 0x2b, 0x43, 0x0c, 0x81, 0xea, 0xf1,
    0xaf, 0x72, 0xd7, 0xb5, 0xe7, 0x94, 0xfc, 0x98, 0xa3, 0x13, 0x92, 0x76, 0x87, 0x97, 0x57, 0xce,
    0x45, 0x3b, 0x52, 0x6e, 0xf9, 0xbf, 0x6c, 0xeb, 0x99, 0x97, 0x9b, 0x84, 0x23, 0xb9, 0x0f, 0x44,
    0x61, 0xa2, 0x2a, 0xf3, 0x7a, 0xab, 0x0c, 0xf5, 0x73, 0x3f, 0x75, 0x97, 0xab, 0xe4, 0x4d, 0x31,
    0xc7, 0x32, 0xdb, 0x68, 0xa1, 0x81, 0xc6, 0xcb, 0xbe, 0x60, 0x7d, 0x8c, 0x0e, 0x52, 0xe0, 0x65,
    0x5f, 0xd9, 0x99, 0x6d, 0xc5, 0x84, 0xec, 0xa0, 0xbe, 0x87, 0xaf, 0xbc, 0xd7, 0x8a, 0x33, 0x7d,
    0x17, 0xb1, 0xdb, 0xa9, 0xe8, 0x28, 0xbb, 0xd8, 0x1e, 0x29, 0x13, 0x17, 0x14, 0x4e, 0x7f, 0xf8,
    0x9f, 0x55, 0x61, 0x97, 0x09, 0xb0, 0x96, 0xcb, 0xb9, 0xea, 0x47, 0x4c, 0xea, 0xd2, 0x64, 0xc2,
    0x07, 0x3f, 0xe4, 0x97, 0x40, 0xc0, 0x1f, 0x00, 0xe1, 0x09, 0x10, 0x60, 0x66, 0x98, 0x3d, 0x21,
    0xe5, 0xf8, 0x3f, 0x08, 0x6e, 0x2e, 0x82, 0x3c, 0x87, 0x9c, 0xd4, 0x3c, 0xef, 0x70, 0x0d, 0x2a,
    0x35, 0x2a, 0x9b, 0xab, 0xd6, 0x12, 0xd0, 0x3c, 0xad, 0x02, 0xdb, 0x13, 0x4b, 0x7e, 0x22, 0x5a,
    0x5f, 0x02, 0x03, 0x01, 0x00, 0x01};

uint8_t privKey[] = {0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41,
  0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x45,
  0x76, 0x51, 0x49, 0x42, 0x41, 0x44, 0x41, 0x4E, 0x42, 0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x53, 0x43, 0x42, 0x4B, 0x63, 0x77,
  0x67, 0x67, 0x53, 0x6A, 0x41, 0x67, 0x45, 0x41, 0x41, 0x6F, 0x49, 0x42, 0x41, 0x51, 0x44, 0x4C,
  0x47, 0x75, 0x31, 0x72, 0x61, 0x70, 0x58, 0x31, 0x73, 0x63, 0x34, 0x42, 0x0A, 0x4F, 0x6B, 0x7A,
  0x38, 0x71, 0x79, 0x57, 0x35, 0x53, 0x79, 0x35, 0x6B, 0x6F, 0x6A, 0x41, 0x30, 0x35, 0x43, 0x55,
  0x4B, 0x66, 0x71, 0x74, 0x44, 0x77, 0x4E, 0x38, 0x36, 0x6A, 0x42, 0x4B, 0x5A, 0x4F, 0x76, 0x45,
  0x72, 0x45, 0x52, 0x6B, 0x49, 0x31, 0x4C, 0x52, 0x78, 0x76, 0x73, 0x4D, 0x64, 0x53, 0x32, 0x79,
  0x61, 0x32, 0x63, 0x33, 0x61, 0x6B, 0x47, 0x45, 0x71, 0x4C, 0x75, 0x6B, 0x44, 0x0A, 0x55, 0x6A,
  0x35, 0x74, 0x35, 0x61, 0x49, 0x6B, 0x31, 0x72, 0x41, 0x76, 0x43, 0x65, 0x58, 0x44, 0x64, 0x4E,
  0x44, 0x50, 0x34, 0x42, 0x32, 0x50, 0x55, 0x70, 0x78, 0x51, 0x43, 0x6E, 0x69, 0x69, 0x39, 0x6E,
  0x6B, 0x49, 0x2B, 0x6D, 0x67, 0x72, 0x57, 0x69, 0x74, 0x44, 0x44, 0x49, 0x48, 0x71, 0x38, 0x61,
  0x39, 0x79, 0x31, 0x37, 0x58, 0x6E, 0x6C, 0x50, 0x79, 0x59, 0x6F, 0x78, 0x4F, 0x53, 0x0A, 0x64,
  0x6F, 0x65, 0x58, 0x56, 0x38, 0x35, 0x46, 0x4F, 0x31, 0x4A, 0x75, 0x2B, 0x62, 0x39, 0x73, 0x36,
  0x35, 0x6D, 0x58, 0x6D, 0x34, 0x51, 0x6A, 0x75, 0x51, 0x39, 0x45, 0x59, 0x61, 0x49, 0x71, 0x38,
  0x33, 0x71, 0x72, 0x44, 0x50, 0x56, 0x7A, 0x50, 0x33, 0x57, 0x58, 0x71, 0x2B, 0x52, 0x4E, 0x4D,
  0x63, 0x63, 0x79, 0x32, 0x32, 0x69, 0x68, 0x67, 0x63, 0x62, 0x4C, 0x76, 0x6D, 0x42, 0x39, 0x0A,
  0x6A, 0x41, 0x35, 0x53, 0x34, 0x47, 0x56, 0x66, 0x32, 0x5A, 0x6C, 0x74, 0x78, 0x59, 0x54, 0x73,
  0x6F, 0x4C, 0x36, 0x48, 0x72, 0x37, 0x7A, 0x58, 0x69, 0x6A, 0x4E, 0x39, 0x46, 0x37, 0x48, 0x62,
  0x71, 0x65, 0x67, 0x6F, 0x75, 0x39, 0x67, 0x65, 0x4B, 0x52, 0x4D, 0x58, 0x46, 0x45, 0x35, 0x2F,
  0x2B, 0x4A, 0x39, 0x56, 0x59, 0x5A, 0x63, 0x4A, 0x73, 0x4A, 0x62, 0x4C, 0x75, 0x65, 0x70, 0x48,
  0x0A, 0x54, 0x4F, 0x72, 0x53, 0x5A, 0x4D, 0x49, 0x48, 0x50, 0x2B, 0x53, 0x58, 0x51, 0x4D, 0x41,
  0x66, 0x41, 0x4F, 0x45, 0x4A, 0x45, 0x47, 0x42, 0x6D, 0x6D, 0x44, 0x30, 0x68, 0x35, 0x66, 0x67,
  0x2F, 0x43, 0x47, 0x34, 0x75, 0x67, 0x6A, 0x79, 0x48, 0x6E, 0x4E, 0x51, 0x38, 0x37, 0x33, 0x41,
  0x4E, 0x4B, 0x6A, 0x55, 0x71, 0x6D, 0x36, 0x76, 0x57, 0x45, 0x74, 0x41, 0x38, 0x72, 0x51, 0x4C,
  0x62, 0x0A, 0x45, 0x30, 0x74, 0x2B, 0x49, 0x6C, 0x70, 0x66, 0x41, 0x67, 0x4D, 0x42, 0x41, 0x41,
  0x45, 0x43, 0x67, 0x67, 0x45, 0x41, 0x4C, 0x7A, 0x43, 0x62, 0x64, 0x7A, 0x69, 0x31, 0x6A, 0x50,
  0x64, 0x35, 0x38, 0x4D, 0x6B, 0x56, 0x2B, 0x43, 0x4C, 0x66, 0x79, 0x66, 0x53, 0x51, 0x32, 0x2B,
  0x72, 0x66, 0x48, 0x6E, 0x72, 0x66, 0x72, 0x46, 0x65, 0x50, 0x2F, 0x56, 0x63, 0x44, 0x78, 0x72,
  0x75, 0x69, 0x0A, 0x32, 0x70, 0x31, 0x61, 0x53, 0x58, 0x4A, 0x59, 0x69, 0x62, 0x65, 0x36, 0x45,
  0x53, 0x2B, 0x4D, 0x62, 0x2F, 0x4D, 0x46, 0x55, 0x64, 0x6C, 0x48, 0x50, 0x67, 0x41, 0x4C, 0x77,
  0x31, 0x78, 0x51, 0x34, 0x57, 0x65, 0x72, 0x66, 0x36, 0x63, 0x36, 0x44, 0x43, 0x73, 0x68, 0x6C,
  0x6C, 0x78, 0x4C, 0x57, 0x53, 0x56, 0x38, 0x47, 0x73, 0x42, 0x73, 0x76, 0x63, 0x38, 0x6F, 0x36,
  0x47, 0x50, 0x32, 0x0A, 0x63, 0x59, 0x36, 0x6F, 0x77, 0x70, 0x42, 0x44, 0x77, 0x63, 0x62, 0x61,
  0x68, 0x47, 0x4B, 0x55, 0x6B, 0x50, 0x30, 0x45, 0x6B, 0x62, 0x39, 0x53, 0x30, 0x58, 0x4C, 0x4A,
  0x57, 0x63, 0x47, 0x53, 0x47, 0x35, 0x61, 0x55, 0x6E, 0x48, 0x4A, 0x58, 0x52, 0x37, 0x69, 0x6E,
  0x78, 0x34, 0x63, 0x5A, 0x6C, 0x66, 0x6F, 0x4C, 0x6E, 0x72, 0x45, 0x51, 0x65, 0x36, 0x68, 0x55,
  0x78, 0x73, 0x4D, 0x71, 0x0A, 0x62, 0x30, 0x64, 0x48, 0x78, 0x64, 0x48, 0x44, 0x42, 0x4D, 0x64,
  0x47, 0x66, 0x56, 0x57, 0x77, 0x67, 0x4B, 0x6F, 0x6A, 0x4F, 0x6A, 0x70, 0x53, 0x2F, 0x39, 0x38,
  0x6D, 0x45, 0x55, 0x79, 0x37, 0x56, 0x42, 0x2F, 0x36, 0x61, 0x32, 0x6C, 0x72, 0x65, 0x67, 0x6C,
  0x76, 0x6A, 0x63, 0x2F, 0x32, 0x6E, 0x4B, 0x43, 0x4B, 0x74, 0x59, 0x37, 0x37, 0x44, 0x37, 0x64,
  0x54, 0x71, 0x6C, 0x47, 0x46, 0x0A, 0x78, 0x7A, 0x41, 0x42, 0x61, 0x57, 0x75, 0x38, 0x36, 0x4D,
  0x43, 0x5A, 0x34, 0x2F, 0x51, 0x31, 0x33, 0x4C, 0x76, 0x2B, 0x42, 0x65, 0x66, 0x62, 0x71, 0x74,
  0x49, 0x39, 0x73, 0x71, 0x5A, 0x5A, 0x77, 0x6A, 0x72, 0x64, 0x55, 0x68, 0x51, 0x48, 0x38, 0x56,
  0x43, 0x78, 0x72, 0x79, 0x32, 0x51, 0x56, 0x4D, 0x51, 0x57, 0x51, 0x69, 0x6E, 0x57, 0x68, 0x41,
  0x74, 0x36, 0x4D, 0x71, 0x54, 0x34, 0x0A, 0x53, 0x42, 0x53, 0x54, 0x72, 0x6F, 0x6C, 0x5A, 0x7A,
  0x77, 0x72, 0x71, 0x6A, 0x65, 0x38, 0x4D, 0x50, 0x4A, 0x39, 0x31, 0x75, 0x61, 0x4E, 0x4D, 0x64,
  0x58, 0x47, 0x4C, 0x63, 0x48, 0x4C, 0x49, 0x32, 0x36, 0x73, 0x58, 0x7A, 0x76, 0x37, 0x4B, 0x53,
  0x51, 0x4B, 0x42, 0x67, 0x51, 0x44, 0x76, 0x63, 0x77, 0x73, 0x50, 0x55, 0x55, 0x76, 0x41, 0x39,
  0x5A, 0x32, 0x5A, 0x58, 0x39, 0x58, 0x35, 0x0A, 0x6D, 0x49, 0x78, 0x4D, 0x54, 0x42, 0x4E, 0x64,
  0x45, 0x46, 0x7A, 0x56, 0x62, 0x55, 0x50, 0x75, 0x4B, 0x4B, 0x41, 0x31, 0x79, 0x57, 0x6E, 0x31,
  0x55, 0x4D, 0x44, 0x4E, 0x63, 0x55, 0x6A, 0x71, 0x68, 0x2B, 0x7A, 0x65, 0x2F, 0x37, 0x6B, 0x33,
  0x79, 0x46, 0x78, 0x6B, 0x68, 0x30, 0x51, 0x46, 0x33, 0x31, 0x62, 0x71, 0x36, 0x30, 0x65, 0x4C,
  0x39, 0x30, 0x47, 0x49, 0x53, 0x69, 0x41, 0x4F, 0x0A, 0x35, 0x4B, 0x4F, 0x57, 0x4D, 0x39, 0x45,
  0x4B, 0x6F, 0x2B, 0x78, 0x41, 0x51, 0x32, 0x62, 0x61, 0x4B, 0x31, 0x4D, 0x66, 0x4F, 0x59, 0x31,
  0x47, 0x2B, 0x38, 0x6A, 0x7A, 0x42, 0x58, 0x55, 0x70, 0x42, 0x73, 0x39, 0x34, 0x6B, 0x35, 0x33,
  0x53, 0x38, 0x38, 0x79, 0x58, 0x6D, 0x4B, 0x36, 0x6E, 0x79, 0x64, 0x67, 0x76, 0x37, 0x30, 0x42,
  0x4A, 0x38, 0x5A, 0x68, 0x35, 0x66, 0x6B, 0x55, 0x71, 0x0A, 0x57, 0x32, 0x30, 0x6F, 0x53, 0x62,
  0x68, 0x6B, 0x68, 0x6A, 0x52, 0x64, 0x53, 0x7A, 0x48, 0x32, 0x6B, 0x52, 0x47, 0x69, 0x72, 0x67,
  0x2B, 0x55, 0x53, 0x77, 0x4B, 0x42, 0x67, 0x51, 0x44, 0x5A, 0x4A, 0x4D, 0x6E, 0x72, 0x79, 0x32,
  0x45, 0x78, 0x61, 0x2F, 0x33, 0x45, 0x71, 0x37, 0x50, 0x62, 0x6F, 0x73, 0x78, 0x41, 0x50, 0x4D,
  0x69, 0x59, 0x6E, 0x6B, 0x35, 0x4A, 0x41, 0x50, 0x53, 0x47, 0x0A, 0x79, 0x32, 0x7A, 0x30, 0x5A,
  0x37, 0x54, 0x55, 0x62, 0x2B, 0x75, 0x48, 0x51, 0x4F, 0x2F, 0x2B, 0x78, 0x50, 0x4D, 0x37, 0x6E,
  0x43, 0x30, 0x75, 0x79, 0x4C, 0x49, 0x4D, 0x44, 0x39, 0x6C, 0x61, 0x54, 0x4D, 0x48, 0x77, 0x6E,
  0x36, 0x73, 0x37, 0x2F, 0x4C, 0x62, 0x47, 0x6F, 0x45, 0x50, 0x31, 0x57, 0x52, 0x67, 0x70, 0x6F,
  0x59, 0x48, 0x2F, 0x42, 0x31, 0x34, 0x6B, 0x2F, 0x52, 0x6E, 0x36, 0x0A, 0x66, 0x75, 0x77, 0x52,
  0x4E, 0x36, 0x32, 0x49, 0x6F, 0x39, 0x74, 0x63, 0x39, 0x2B, 0x41, 0x43, 0x4C, 0x74, 0x55, 0x42,
  0x37, 0x76, 0x74, 0x47, 0x61, 0x79, 0x33, 0x2B, 0x67, 0x52, 0x77, 0x59, 0x74, 0x53, 0x43, 0x32,
  0x62, 0x35, 0x65, 0x64, 0x38, 0x6C, 0x49, 0x69, 0x65, 0x67, 0x74, 0x54, 0x6B, 0x65, 0x61, 0x30,
  0x68, 0x30, 0x75, 0x44, 0x53, 0x52, 0x78, 0x41, 0x74, 0x56, 0x73, 0x33, 0x0A, 0x6E, 0x35, 0x6B,
  0x79, 0x61, 0x32, 0x51, 0x39, 0x76, 0x51, 0x4B, 0x42, 0x67, 0x46, 0x4A, 0x75, 0x46, 0x7A, 0x4F,
  0x5A, 0x74, 0x2B, 0x74, 0x67, 0x59, 0x6E, 0x57, 0x6E, 0x51, 0x55, 0x45, 0x67, 0x57, 0x38, 0x50,
  0x30, 0x4F, 0x49, 0x4A, 0x45, 0x48, 0x4D, 0x45, 0x34, 0x55, 0x54, 0x64, 0x4F, 0x63, 0x77, 0x43,
  0x78, 0x4B, 0x72, 0x48, 0x52, 0x72, 0x39, 0x33, 0x4A, 0x6A, 0x75, 0x46, 0x32, 0x0A, 0x45, 0x33,
  0x77, 0x64, 0x4B, 0x6F, 0x54, 0x69, 0x69, 0x37, 0x50, 0x72, 0x77, 0x4F, 0x59, 0x49, 0x6F, 0x61,
  0x4A, 0x54, 0x68, 0x70, 0x6A, 0x50, 0x63, 0x4A, 0x62, 0x62, 0x64, 0x62, 0x66, 0x4B, 0x79, 0x2B,
  0x6E, 0x73, 0x51, 0x70, 0x31, 0x59, 0x47, 0x76, 0x39, 0x77, 0x64, 0x4A, 0x72, 0x4D, 0x61, 0x56,
  0x77, 0x4A, 0x63, 0x76, 0x49, 0x70, 0x77, 0x56, 0x36, 0x76, 0x31, 0x55, 0x70, 0x66, 0x0A, 0x56,
  0x74, 0x4C, 0x61, 0x64, 0x6D, 0x31, 0x6C, 0x6B, 0x6C, 0x76, 0x70, 0x71, 0x73, 0x36, 0x47, 0x4E,
  0x4D, 0x38, 0x6A, 0x6E, 0x4D, 0x30, 0x58, 0x78, 0x33, 0x61, 0x6A, 0x6D, 0x6D, 0x6E, 0x66, 0x65,
  0x57, 0x39, 0x79, 0x47, 0x58, 0x45, 0x35, 0x70, 0x68, 0x4D, 0x72, 0x7A, 0x4C, 0x4A, 0x6C, 0x39,
  0x46, 0x30, 0x39, 0x63, 0x49, 0x32, 0x4C, 0x41, 0x6F, 0x47, 0x42, 0x41, 0x4E, 0x58, 0x76, 0x0A,
  0x75, 0x67, 0x56, 0x58, 0x72, 0x70, 0x32, 0x62, 0x73, 0x54, 0x31, 0x6F, 0x6B, 0x64, 0x36, 0x75,
  0x53, 0x61, 0x42, 0x73, 0x67, 0x70, 0x4A, 0x6A, 0x50, 0x65, 0x77, 0x4E, 0x52, 0x64, 0x33, 0x63,
  0x5A, 0x4B, 0x39, 0x7A, 0x30, 0x61, 0x53, 0x50, 0x31, 0x44, 0x54, 0x41, 0x31, 0x50, 0x4E, 0x6B,
  0x70, 0x65, 0x51, 0x77, 0x48, 0x67, 0x2F, 0x2B, 0x36, 0x66, 0x53, 0x61, 0x56, 0x4F, 0x48, 0x7A,
  0x0A, 0x79, 0x41, 0x78, 0x44, 0x73, 0x39, 0x68, 0x35, 0x52, 0x72, 0x62, 0x78, 0x52, 0x61, 0x4E,
  0x66, 0x73, 0x54, 0x2B, 0x72, 0x41, 0x55, 0x48, 0x37, 0x78, 0x31, 0x53, 0x59, 0x44, 0x56, 0x56,
  0x51, 0x59, 0x56, 0x4D, 0x68, 0x55, 0x52, 0x62, 0x54, 0x6F, 0x5A, 0x65, 0x36, 0x47, 0x2F, 0x6A,
  0x71, 0x6E, 0x54, 0x43, 0x33, 0x66, 0x4E, 0x66, 0x48, 0x56, 0x31, 0x78, 0x74, 0x5A, 0x66, 0x6F,
  0x74, 0x0A, 0x30, 0x6C, 0x6F, 0x4D, 0x48, 0x67, 0x77, 0x65, 0x70, 0x36, 0x2B, 0x53, 0x49, 0x4D,
  0x43, 0x6F, 0x65, 0x65, 0x32, 0x5A, 0x63, 0x74, 0x75, 0x5A, 0x56, 0x33, 0x32, 0x6C, 0x63, 0x49,
  0x61, 0x66, 0x39, 0x72, 0x62, 0x48, 0x4F, 0x63, 0x37, 0x64, 0x41, 0x6F, 0x47, 0x41, 0x65, 0x51,
  0x38, 0x6B, 0x38, 0x53, 0x49, 0x4C, 0x4E, 0x47, 0x36, 0x44, 0x4F, 0x41, 0x33, 0x31, 0x54, 0x45,
  0x35, 0x50, 0x0A, 0x6D, 0x30, 0x31, 0x41, 0x4A, 0x49, 0x59, 0x77, 0x37, 0x41, 0x6C, 0x52, 0x33,
  0x75, 0x6F, 0x2F, 0x52, 0x4E, 0x61, 0x43, 0x2B, 0x78, 0x59, 0x64, 0x50, 0x55, 0x33, 0x54, 0x73,
  0x6B, 0x75, 0x41, 0x4C, 0x78, 0x78, 0x69, 0x44, 0x52, 0x2F, 0x57, 0x73, 0x4C, 0x45, 0x51, 0x42,
  0x43, 0x6A, 0x6B, 0x46, 0x57, 0x6D, 0x6D, 0x4A, 0x41, 0x57, 0x6E, 0x51, 0x55, 0x44, 0x74, 0x62,
  0x6E, 0x59, 0x4E, 0x0A, 0x53, 0x63, 0x77, 0x52, 0x38, 0x47, 0x32, 0x4A, 0x36, 0x46, 0x6E, 0x72,
  0x45, 0x43, 0x74, 0x62, 0x74, 0x79, 0x73, 0x37, 0x33, 0x57, 0x41, 0x56, 0x47, 0x6F, 0x6F, 0x46,
  0x5A, 0x6E, 0x63, 0x6D, 0x50, 0x4C, 0x50, 0x38, 0x6C, 0x78, 0x4C, 0x79, 0x62, 0x6C, 0x53, 0x42,
  0x44, 0x45, 0x4C, 0x79, 0x61, 0x5A, 0x76, 0x2F, 0x62, 0x41, 0x73, 0x50, 0x6C, 0x4D, 0x4F, 0x39,
  0x62, 0x44, 0x35, 0x63, 0x0A, 0x4A, 0x2B, 0x4E, 0x53, 0x42, 0x61, 0x61, 0x2B, 0x6F, 0x69, 0x4C,
  0x6C, 0x31, 0x77, 0x6D, 0x43, 0x61, 0x35, 0x4D, 0x43, 0x66, 0x6C, 0x63, 0x3D, 0x0A, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4B,
  0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A};

void *StdMalloc(uint32_t len) {
    return malloc((uint32_t)len);
}
void PrintLastError(void) {
    const char *file = NULL;
    uint32_t line = 0;
    BSL_ERR_GetLastErrorFileLine(&file, &line);
    printf("failed at file %s at line %d\n", file, line);
}

void PrintHex(const uint8_t* data, uint32_t len) {
    for (uint32_t i = 0; i < len; i++) {
        printf("%02X", data[i]);
        if ((i + 1) % 16 == 0 && i + 1 < len) {
            printf("\n");
        } else {
            printf(" ");
        }
    }
    printf("\n");
}

int main(void) {
    BSL_ERR_Init(); // Initialize error code module
    BSL_SAL_CallBack_Ctrl(BSL_SAL_MEM_MALLOC, StdMalloc); // Register memory allocation function
    BSL_SAL_CallBack_Ctrl(BSL_SAL_MEM_FREE, free); // Register memory free function

    int32_t ret = 1;

    HITLS_AUTH_PrivPassCtx *client = NULL;
    HITLS_AUTH_PrivPassCtx *issuer = NULL;
    HITLS_AUTH_PrivPassCtx *server = NULL;
    HITLS_AUTH_PrivPassToken *tokenChallenge = NULL;
    HITLS_AUTH_PrivPassToken *tokenRequest = NULL;
    HITLS_AUTH_PrivPassToken *tokenResponse = NULL;
    HITLS_AUTH_PrivPassToken *finalToken = NULL;
    uint8_t *tokenChallengeBuff = NULL;
    uint32_t tokenChallengeLen = 0;
    uint8_t *tokenRequestBuff = NULL;
    uint32_t tokenRequestLen = 0;
    uint8_t *tokenResponseBuff = NULL;
    uint32_t tokenResponseLen = 0;
    uint8_t *finalTokenBuff = NULL;
    uint32_t finalTokenLen = 0;

    // Construct parameter structure
    uint16_t tokenTypeValue = 0x0002;
    uint8_t issuerName[] = "Example Issuer";
    uint8_t redemption[] = ""; // Length must be 0 or 32
    uint8_t originInfo[] = "Example Origin";

    BSL_Param param[5] = {
        {AUTH_PARAM_PRIVPASS_TOKENCHALLENGE_TYPE, BSL_PARAM_TYPE_UINT16, &tokenTypeValue, 2, 2},
        {AUTH_PARAM_PRIVPASS_TOKENCHALLENGE_ISSUERNAME, BSL_PARAM_TYPE_OCTETS_PTR, issuerName, sizeof(issuerName),
            sizeof(issuerName)},
        {AUTH_PARAM_PRIVPASS_TOKENCHALLENGE_REDEMPTION, BSL_PARAM_TYPE_OCTETS_PTR, redemption, 0, 0},
        {AUTH_PARAM_PRIVPASS_TOKENCHALLENGE_ORIGININFO, BSL_PARAM_TYPE_OCTETS_PTR, originInfo, sizeof(originInfo),
            sizeof(originInfo)},
        BSL_PARAM_END
    };
    ret = CRYPT_EAL_Init(CRYPT_EAL_INIT_CPU | CRYPT_EAL_INIT_PROVIDER);
    if (ret != CRYPT_SUCCESS) {
        printf("error code is %x\n", ret);
        PrintLastError();
        goto EXIT;
    }
    // Initialize random number generator. NULL means using default entropy source, 
    // users can choose to use their own entropy source
    ret = CRYPT_EAL_ProviderRandInitCtx(NULL, CRYPT_RAND_SHA256, "provider=default", NULL, 0, NULL);
    if (ret != CRYPT_SUCCESS) { 
        printf("error code is %x\n", ret);
        PrintLastError();
        goto EXIT;
    }
    client = HITLS_AUTH_PrivPassNewCtx(HITLS_AUTH_PRIVPASS_PUB_VERIFY_TOKENS);
    issuer = HITLS_AUTH_PrivPassNewCtx(HITLS_AUTH_PRIVPASS_PUB_VERIFY_TOKENS);
    server = HITLS_AUTH_PrivPassNewCtx(HITLS_AUTH_PRIVPASS_PUB_VERIFY_TOKENS);
    if (!client || !issuer || !server) {
        printf("Failed to create contexts\n");
        PrintLastError();
        goto EXIT;
    }

    // Set keys
    if (HITLS_AUTH_PrivPassSetPubkey(client, pubKey, sizeof(pubKey)) != HITLS_AUTH_SUCCESS ||
        HITLS_AUTH_PrivPassSetPubkey(issuer, pubKey, sizeof(pubKey)) != HITLS_AUTH_SUCCESS ||
        HITLS_AUTH_PrivPassSetPrvkey(issuer, NULL, privKey, sizeof(privKey)) != HITLS_AUTH_SUCCESS ||
        HITLS_AUTH_PrivPassSetPubkey(server, pubKey, sizeof(pubKey)) != HITLS_AUTH_SUCCESS) {
        printf("Failed to set keys\n");
        PrintLastError();
        goto EXIT;
    }

    printf("\ntokenChallenge: server ------> client\n");
    if (HITLS_AUTH_PrivPassGenTokenChallenge(server, param, &tokenChallenge) != HITLS_AUTH_SUCCESS) {
        printf("Failed to generate token challenge\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(server, tokenChallenge, NULL, &tokenChallengeLen) != HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize token challenge\n");
        PrintLastError();
        goto EXIT;
    }
    tokenChallengeBuff = BSL_SAL_Malloc(tokenChallengeLen);
    if (tokenChallengeBuff == NULL) {
        printf("Failed to allocate memory for token challenge\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(server, tokenChallenge, tokenChallengeBuff, &tokenChallengeLen) !=
        HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize token challenge\n");
        PrintLastError();
        goto EXIT;
    }
    PrintHex(tokenChallengeBuff, tokenChallengeLen);

    printf("\ntokenRequest: client ------> issuer\n");
    if (HITLS_AUTH_PrivPassGenTokenReq(client, tokenChallenge, &tokenRequest) != HITLS_AUTH_SUCCESS) {
        printf("Failed to generate token request\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(client, tokenRequest, NULL, &tokenRequestLen) != HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize token request\n");
        PrintLastError();
        goto EXIT;
    }
    tokenRequestBuff = BSL_SAL_Malloc(tokenRequestLen);
    if (tokenRequestBuff == NULL) {
        printf("Failed to allocate memory for token request\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(client, tokenRequest, tokenRequestBuff, &tokenRequestLen)
        != HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize token request\n");
        PrintLastError();
        goto EXIT;
    }
    PrintHex(tokenRequestBuff, tokenRequestLen);

    printf("\ntokenResponse: issuer ------> client\n");
    if (HITLS_AUTH_PrivPassGenTokenResponse(issuer, tokenRequest, &tokenResponse) != HITLS_AUTH_SUCCESS) {
        printf("Failed to generate token response\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(client, tokenResponse, NULL, &tokenResponseLen) != HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize token response\n");
        PrintLastError();
        goto EXIT;
    }
    tokenResponseBuff = BSL_SAL_Malloc(tokenResponseLen);
    if (tokenResponseBuff == NULL) {
        printf("Failed to allocate memory for token response\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(client, tokenResponse, tokenResponseBuff, &tokenResponseLen) !=
        HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize token response\n");
        PrintLastError();
        goto EXIT;
    }
    PrintHex(tokenResponseBuff, tokenResponseLen);

    printf("\nfinalToken: client ------> server\n");
    if (HITLS_AUTH_PrivPassGenToken(client, tokenChallenge, tokenResponse, &finalToken) != HITLS_AUTH_SUCCESS) {
        printf("Failed to generate final token\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(client, finalToken, NULL, &finalTokenLen) != HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize final token\n");
        PrintLastError();
        goto EXIT;
    }
    finalTokenBuff = BSL_SAL_Malloc(finalTokenLen);
    if (finalTokenBuff == NULL) {
        printf("Failed to allocate memory for final token\n");
        PrintLastError();
        goto EXIT;
    }
    if (HITLS_AUTH_PrivPassSerialization(client, finalToken, finalTokenBuff, &finalTokenLen) != HITLS_AUTH_SUCCESS) {
        printf("Failed to serialize final token\n");
        PrintLastError();
        goto EXIT;
    }
    PrintHex(finalTokenBuff, finalTokenLen);

    printf("\nverifyToken: server\n");
    if (HITLS_AUTH_PrivPassVerifyToken(server, tokenChallenge, finalToken) != HITLS_AUTH_SUCCESS) {
        printf("Token verification failed\n");
        PrintLastError();
        goto EXIT;
    }
    printf("Privacy pass public token verify process completed successfully!\n");
    ret = HITLS_AUTH_SUCCESS;

EXIT:
    HITLS_AUTH_PrivPassFreeToken(tokenChallenge);
    HITLS_AUTH_PrivPassFreeToken(tokenRequest);
    HITLS_AUTH_PrivPassFreeToken(tokenResponse);
    HITLS_AUTH_PrivPassFreeToken(finalToken);
    HITLS_AUTH_PrivPassFreeCtx(client);
    HITLS_AUTH_PrivPassFreeCtx(issuer);
    HITLS_AUTH_PrivPassFreeCtx(server);
    BSL_SAL_FREE(tokenChallengeBuff);
    BSL_SAL_FREE(tokenRequestBuff);
    BSL_SAL_FREE(tokenResponseBuff);
    BSL_SAL_FREE(finalTokenBuff);
    return ret;
}
